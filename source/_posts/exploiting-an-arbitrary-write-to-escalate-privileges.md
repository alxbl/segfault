---
title: Exploiting an Arbitrary Write to Escalate Privileges
date: 2019-05-20 21:54:53
tags:
    - Exploitation
    - Windows
    - Kernel
---

This post describes the blind exploitation of a known driver vulnerability in
the context of [@HackSysTeam][1]'s Advanced Windows Kernel Exploitation training
given at [NorthSec 2019][2] in Montreal.


[1]: https://twitter.com/ "@HackSysTeam on Twitter"
[2]: https://nsec.io "NorthSec Official Website"

# Introduction

Last week I attended NorthSec 2019 and was forunate enough to take part in the
Advanced Windows Kernel Exploitation training offered by HackSysTeam. The course
was overall very pleasant and covered foundational kernel space concepts all the
way up to advanced mitigation bypasses and exploitation. The material was
extremely well presented and explained, making it easy to follow along.

The instructors also ran a mini CTF "competition" (which I may have taken a bit
too seriously!) in parallel to the training to provide an environment in which
to put the attendees' newly acquired knowledge to the test. The track had
increasingly difficult challenges that culminated in exploiting a real driver
without any prior knowledge of its internals. While nobody solved it during the
training, I could not let go and decided that I would finish it no matter what.

In this article I'll try to give a detailed account of each step taken along the
way to get a fully working exploit.

# Recon

The CTF challenge description only mentions a `System Mechanics` driver to
exploit, but does not point to the driver file itself, nor provide any
information about how to interact with it, leaving it up to the participant to
figure out the where, what, and how. Thankfully, a `ampse.sys` and `amp.sys`
file is provided, meaning that the driver to exploit is likely one of those two.

The first step is thus to setup a VM and install the program, and take a look at
the installed drivers using a tool called [WinObj][3]. After confirming that the
drivers are indeed present, it's important to identify which driver exposes
functionality to userland. Here, it's helpful to know that all kernel drivers
are **required** to create a `Device` in order to expose any kind of
functionality to the outside world, including other kernel drivers. This means
it's easy to spot the device using `WinObj`.

[3]: https://... "Windows Object Explorer"

## Identifying the IOCTL Handler

Driver objects in Windows expose a limited number of I/O Request Packet (`IRP`)
slots which act as a low-level callback interface for specific events that occur
in the system. A few examples include `IRP_MJ_CREATE` and `IRP_MJ_CLOSE`. From a
userland perspective, the interesting `IRP` code is `IRP_MJ_DEVICE_CONTROL`,
which is a generic packet that contains an operation code named an I/O control
code, or `IOCTL` for short. Without diving too much into internals, this allows
the driver to expose custom functionality for users to call through the Windows
`IoDeviceControl` API call in user mode, as long as they can acquire a handle to
the driver device.

Since the IRP table must be populated before returning from the `DriverEntry`
(the equivalent of `main` for kernel drivers), it's relatively straightforward
to locate the IOCTL handling routine and thus identify exposed IOCTLs by
reversing the driver from its entry point.

One way to do that is to use Ghidra and locate calls to `IoCreateDevice`, which
both reveals the device name as well as the (TODO)

Opening the driver `amp.sys` in Ghidra and looking for cross-references to
`IofCompleteRequest` is the easiest way to locate

## Discovering the Crash
## Finding the Vulnerability

# Crafting the Exploit

## No Read? No Problem!
## Write Limitation
## QuerySystemHandleInfomation to the Rescue

(Note: This won't work at low integrity level.)

## Full Exploit Chain



##########################

```
$ r2 amp.sys
 -- Too old to crash
[0x00026f90]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Check for vtables
[x] Type matching analysis for all functions (aaft)
[x] Use -AA or aaaa to perform additional experimental analysis.
[0x00026f90]> ax~IoCreateDevice
                        fcn.0002cfe0+191 0x2d09f ->      CALL -> 0x31348 sym.imp.ntoskrnl.exe_IoCreateDevice
[0x00026f90]> pd 10 @ 0x2d09f - 10
|           0x0002d095      0000           add byte [rax], al
|           0x0002d097      488b8c249000.  mov rcx, qword [arg_90h]    ; [0x90:8]=-1 ; 144
|           0x0002d09f      ff15a3420000   call qword sym.imp.ntoskrnl.exe_IoCreateDevice ; [0x31348:8]=0x2b4d4 reloc.ntoskrnl.exe_IoCreateDevice
|           0x0002d0a5      89442440       mov dword [var_40h], eax
|           0x0002d0a9      488b05209f00.  mov rax, qword [0x00036fd0]; MOV rax = [0x36fd0] = 0x0 r11
 ; [0x36fd0:8]=0
|           0x0002d0b0      488905219f00.  mov qword [0x00036fd8], rax ; [0x36fd8:8]=0
|           0x0002d0b7      48833d119f00.  cmp qword [0x00036fd0], 0   ; [0x36fd0:8]=0
|       ,=< 0x0002d0bf      7505           jne 0x2d0c6
|      ,==< 0x0002d0c1      e936020000     jmp 0x2d2fc
|      ||   ; CODE XREF from fcn.0002cfe0 (0x2d0bf)
|      |`-> 0x0002d0c6      488d150b6600.  lea rdx, str.Device__AMP    ; 0x336d8 ; u"\Device\AMP"
```
